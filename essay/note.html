<!doctype html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<title>知识点.md</title><link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css'><style type='text/css'>html, body {overflow-x: initial !important;}html { font-size: 14px; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 1rem; line-height: 1.42857; color: rgb(51, 51, 51); overflow-x: hidden; background-color: rgb(255, 255, 255); }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: rgb(181, 214, 252); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; padding-bottom: 70px; white-space: pre-wrap; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export #write { margin: 0px auto; }
#write > p:first-child, #write > ul:first-child, #write > ol:first-child, #write > pre:first-child, #write > blockquote:first-child, #write > div:first-child, #write > table:first-child { margin-top: 30px; }
img { max-width: 100%; }
input, button, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
::before, ::after, * { box-sizing: border-box; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write div, #write pre { width: inherit; }
#write p, #write h1, #write h2, #write h3, #write h4, #write h5, #write h6 { position: relative; }
h1 { font-size: 2rem; }
p { -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; }
.mathjax-block { margin-top: 0px; margin-bottom: 0px; -webkit-margin-before: 0rem; -webkit-margin-after: 0rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: bold; font-style: italic; }
a { cursor: pointer; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; margin: 4px 0px 0px; }
tr { page-break-inside: avoid; page-break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; page-break-inside: auto; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right-width: 0px; background-color: inherit; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
pre { white-space: pre-wrap; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences, pre.md-fences { font-size: 0.9rem; display: block; page-break-inside: avoid; text-align: left; overflow: visible; white-space: pre; position: relative !important; background: inherit; }
.md-fences .CodeMirror.CodeMirror-wrap { top: -1.6em; margin-bottom: -1.6em; }
.md-fences.mock-cm { white-space: pre-wrap; }
.show-fences-line-number pre.md-fences { padding-left: 0px; }
.show-fences-line-number pre.md-fences.mock-cm { padding-left: 40px; }
.footnotes { color: rgb(136, 136, 136); font-size: 0.9rem; padding-top: 1em; padding-bottom: 1em; }
.footnotes + .footnotes { margin-top: -1em; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; text-decoration: none; color: rgb(51, 51, 51); font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 1rem; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: normal; text-align: left; box-sizing: content-box; direction: ltr; background: transparent; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li p, li .mathjax-block { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; }
@media print { 
  html, body { height: 100%; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  h1, h2, h3, h4, h5, h6 { page-break-after: avoid; orphans: 2; }
  p { orphans: 4; }
  @page { margin: 20mm 0mm; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
#write pre.md-meta-block { font-size: 0.8rem; min-height: 2.86rem; white-space: pre-wrap; display: block; background: rgb(204, 204, 204); }
p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.mathjax-block { white-space: pre; overflow: hidden; width: 100%; }
p + .mathjax-block { margin-top: -1.143rem; }
.mathjax-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: none; box-shadow: none; }
.task-list { list-style-type: none; }
.task-list-item { position: relative; padding-left: 1em; }
.task-list-item input { position: absolute; top: 0px; left: 0px; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc::after, .md-toc-content::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: bold; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
.md-toc-h6 { margin-left: 12em; }
@media screen and (max-width: 48em) { 
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 8em; }
  .md-toc-h6 { margin-left: 9.5em; }
}
a.md-toc-inner { color: inherit; font-size: inherit; font-style: inherit; font-weight: inherit; text-decoration: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
.md-tag { opacity: 0.5; }
code { text-align: left; }
h1 .md-tag, h2 .md-tag, h3 .md-tag, h4 .md-tag, h5 .md-tag, h6 .md-tag { font-weight: initial; opacity: 0.35; }
a.md-header-anchor.md-print-anchor { border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: none !important; text-decoration: initial !important; text-shadow: initial !important; background: transparent !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.mathjax-block .MathJax_SVG_Display { text-align: center; margin: 1em 0em; position: relative; text-indent: 0px; max-width: none; max-height: none; min-width: 0px; min-height: 0px; width: 100%; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: monospace; }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }


@font-face { font-family: 'Open Sans'; font-style: normal; font-weight: normal; src: local(Open Sans Regular), url(file:///C:/Users/Administrator/AppData/Roaming/Typora/themes/github/400.woff) format(woff); }
@font-face { font-family: 'Open Sans'; font-style: italic; font-weight: normal; src: local(Open Sans Italic), url(file:///C:/Users/Administrator/AppData/Roaming/Typora/themes/github/400i.woff) format(woff); }
@font-face { font-family: 'Open Sans'; font-style: normal; font-weight: bold; src: local(Open Sans Bold), url(file:///C:/Users/Administrator/AppData/Roaming/Typora/themes/github/700.woff) format(woff); }
@font-face { font-family: 'Open Sans'; font-style: italic; font-weight: bold; src: local(Open Sans Bold Italic), url(file:///C:/Users/Administrator/AppData/Roaming/Typora/themes/github/700i.woff) format(woff); }
html { font-size: 16px; }
body { font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; -webkit-font-smoothing: antialiased; }
#write { max-width: 800px; margin: 0px auto; padding: 20px 30px 40px; }
#write::after { height: 80px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
body > :first-child { margin-top: 0px !important; }
body > :last-child { margin-bottom: 0px !important; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; -webkit-font-smoothing: antialiased; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 4px; padding: 0px; margin: 16px 0px; border-width: 0px 0px 1px; border-style: none none solid; overflow: hidden; box-sizing: content-box; border-bottom-color: rgb(221, 221, 221); background-color: rgb(231, 231, 231); }
body > h2:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child { margin-top: 0px; padding-top: 0px; }
body > h1:first-child + h2 { margin-top: 0px; padding-top: 0px; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child { margin-top: 0px; padding-top: 0px; }
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 { margin-top: 0px; padding-top: 0px; }
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p { margin-top: 0px; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left-width: 4px; border-left-style: solid; border-left-color: rgb(221, 221, 221); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; }
table tr { border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); margin: 0px; padding: 0px; background-color: white; }
table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(204, 204, 204); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-gutters { border-right-width: 1px; border-right-style: solid; border-right-color: rgb(221, 221, 221); }
pre.md-fences, .md-fences, code, tt { border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-family: Consolas, 'Liberation Mono', Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; background-color: rgb(248, 248, 248); }
pre.md-fences, .md-fences { margin-bottom: 15px; margin-top: 15px; padding: 8px 1em 6px; }
.task-list { padding-left: 0px; }
.task-list-item { padding-left: 32px; }
.task-list-item input { top: 3px; left: 8px; }
@media screen and (min-width: 914px) { 
}
@media print { 
  table, pre { page-break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; background-color: rgb(247, 247, 247); }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-family: Consolas, 'Liberation Mono', Courier, monospace; padding: 2px 4px 0px; font-size: 0.9em; color: inherit; background-color: rgb(248, 248, 248); }
.md-tag { color: inherit; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; background-color: rgb(250, 250, 250); }


</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-node'><h2><a name='header-c1' class='md-header-anchor '></a>-&gt;C/C++总结&lt;-</h2><h2><a name='header-c6' class='md-header-anchor '></a>指针和引用的区别</h2><ol><li><p>非空区别:在任何情况下都不能使用指向空值的引用，指针可以为空</p><ol><li>合法性区别:在使用引用之前不需要测试它的合法性。相反，指针则应该总被测试，防 止其为空</li><li>可修改区别:指针可以被重新赋值以指向另一个不同的对象，引用在初始化之后不可以在改变</li><li>应用区别:在以下情况下应该使用指针，一是考虑到存在不指向任何对象的可能(在这种情况下可以设置指针为空)，二是需要能够在不同的时候指向不同对象(可以改变指针指向)</li></ol></li></ol><h2><a name='header-c21' class='md-header-anchor '></a>交换两个数，不使用第三个变量</h2><ul><li><p>算术运算</p><p> void fun(int a,int b)
 {</p><pre class='md-fences mock-cm' style='display:block;position:relative'> a = b - a;
 b = b - a;
 a = b + a;</pre><p> }</p></li><li><p>指针地址运算</p></li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>void fun(int *a, int *b)
{
    if(a &lt; b){
        a = (int *)(b - a);
        b = (int *)(b - ((int) a &amp; 0x0000ffff));
        a = (int *)(b + ((int) a &amp; 0x0000ffff));
    }else{
        b = (int *)(a - b);
        a = (int *)(a - ((int) b &amp; 0x0000ffff));
        b = (int *)(a + ((int) b &amp; 0x0000ffff));
    }
}</pre><ul><li>位运算</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>void fun(int a, int b)
{
    a = a^b;
    b = a^b;
    a = a^b;
}</pre><ul><li>栈实现</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>void fun(int a,int b)
{
    stack s;
    Push(s,a);
    Push(s,b);
    a = Pop(s);
    b = Pop(s);
}</pre><h2><a name='header-c46' class='md-header-anchor '></a>const与#define相比有什么不同</h2><p>C++语言可以用const定义常量，也可以用#define定义常量,但是前者比后者有更多的优点：</p><ul><li><p>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换中可能会产生意想不到的错误(边际效应)</p></li><li><p>有些集成化的调试工具可以对const常量进行调试，但不能对宏常量进行调试。在C++程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量</p></li><li><p>const定义的常量可被修改</p><p> const int a = 10;
 *((int *)&amp;a) = 12;</p></li></ul><h2><a name='header-c62' class='md-header-anchor '></a>循环队列</h2><ul><li>入队和出队的操作</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>rear = (rear+1)%m;
front = (front+1)%m;</pre><ul><li>删除操作：front指针</li><li>插入操作：rear指针</li><li>判断队列已满</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>front == (rear+1)%m;</pre><ul><li><p>队列长度</p><p> (rear-front+m)%m;</p></li></ul><h2><a name='header-c85' class='md-header-anchor '></a>union、struct、enum大小区别</h2><ul><li>枚举enum：大小实质上就是整形</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>typedef enum{
            ANUnknow,ANShape,ANData}ANDataType;
sizeof(ANDataType) = 4;</pre><ul><li>联合union：大小则以定义中最大的数据类型为准</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>union AAA{
    double d;
    int i;
}
sizeof(AAA) = 8;</pre><ul><li>结构体struct：字节对齐原则</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>struct BBB{
    double dd;
    int i;
}
sizeof(BBB) = 16;//空结构体的大小为1字节</pre><hr /><h2><a name='header-c102' class='md-header-anchor '></a>编写类String的构造、析构、拷贝构造和赋值函数</h2><p>类原型：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>class String{
    public:
        String(const char *str = NULL);//普通构造函数
        String(const String &amp;other);//拷贝构造函数
        ~String(void);//析构函数
        String &amp; operator =(const String &amp;other);//赋值函数
    private:
        char *m_data;
};</pre><ul><li><p>普通构造函数</p><p> String::String(const char *str)
 {</p><pre class='md-fences mock-cm' style='display:block;position:relative'> if(str == NULL)
 {
     m_data = new char[1];
     *m_data = &#39;\0&#39;;
 }
 else{
     int length = strlen(str);
     m_data = new char[length+1];
     strcpy(m_data, str);
 }</pre><p> }</p><p> </p></li><li><p>析构函数</p></li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>String::~String(void)
{
    delete [] m_data;
}</pre><ul><li>拷贝构造函数</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>String::String(const String &amp;other)
{
    int length = strlen(other.m_data);
    m_data = new char[length+1];
    if(m_data == NULL)
    {
        printf(&quot;申请内存失败\n&quot;);
    }else{
        strcpy(m_data, other.m_data);
    }
}</pre><ul><li>赋值函数</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>String &amp; String::operator =(const String &amp;other)
{
    if(this == other)
    {
        return *this;
        delete [] m_data;
    }
    int length = strlen(other.m_data);
    m_data = new char[length+1];
    if(m_data == NULL)
    {
        printf(&quot;申请内存失败\n&quot;);
    }else{
        strcpy(m_data,other.m_data);
    }
    return *this;
}</pre><h2><a name='header-c134' class='md-header-anchor '></a>拷贝构造函数</h2><p>使用场合：</p><ul><li>新建一个类，并用另一个同类的对象对它初始化</li><li>当函数参数为类对象时，在调用时需要将实参对象传给形参</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>extern void show(Circle cir);
Circle cir1;
show(cir1);</pre><ul><li>当函数返回值是类对象时</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>extern Circle getCircle();
Circle cir = getCircle();</pre><h2><a name='header-c151' class='md-header-anchor '></a>volatile(JD笔试题)</h2><p>作用:作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份</p><ul><li>一个参数既可以是const还可以是volatile吗？解释为什么？
 答：是的，一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</li><li>一个指针可以是volatile 吗？解释为什么？
 答:是的,尽管这并不很常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时</li></ul><h2><a name='header-c161' class='md-header-anchor '></a>mutable的作用</h2><p>在C++程序中，类里面的数据成员加上mutable后，修饰为const的成员变量，就可以修改它了</p><h2><a name='header-c167' class='md-header-anchor '></a>C++菱形继承问题(JD笔试题)</h2><ul><li>什么是菱形继承
假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C</li><li>产生的问题(二义性)
问题是：因为Liger多重继承了Tiger和Lion类，因此Liger类会有两份Animal类的成员（数据和方法），Liger对象&quot;lg&quot;会包含Animal基类的两个子对象。
所以，你会问Liger对象有两个Animal基类的子对象会出现什么问题？再看看上面的代码-调用&quot;lg.getWeight()&quot;将会导致一个编译错误。这是因为编译器并不知道是调用Tiger类的getWeight()还是调用Lion类的getWeight()。所以，调用getWeight方法是不明确的，因此不能通过编译。</li><li>解决方案
如果Lion类和Tiger类在分别继承Animal类时都用virtual来标注，对于每一个Liger对象，C++会保证只有一个Animal类的子对象会被创建</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>class Tiger : virtual public Animal { /* ... */ };</pre><pre class='md-fences mock-cm' style='display:block;position:relative'>class Lion : virtual public Animal { /* ... */ } </pre><p>因为Java不支持多继承，所以不会出现菱形继承问题。但是Java可以通过接口间接实现多重继承</p><pre class='md-fences mock-cm' style='display:block;position:relative'>Class Mule implements Horse,Donkey  
{  
  /* Horse和Donkey是接口*/  
} </pre><hr /><h2><a name='header-c189' class='md-header-anchor '></a>C++多线程</h2><p></p><ul><li><p>线程的创建</p><h1><a name='header-c198' class='md-header-anchor '></a>include<pthread.h></h1><p> void* say_hello(void* arg)
 {</p><pre class='md-fences mock-cm' style='display:block;position:relative'> cout&lt;&lt;&quot;Hello.....&quot;&lt;&lt;endl;</pre><p> }
 pthread_t tids;
 int ret = pthread_creat(&amp;tips,NULL,say_hello,NULL);
如果线程调用到函数在一个类中，那必须将该函数声明为静态函数函数
因为静态成员函数属于静态全局区，线程可以共享这个区域，故可以各自调用</p></li><li><p>在线程调用函数时传入参数</p></li></ul><p>  <br/></p><pre class='md-fences mock-cm' style='display:block;position:relative'>void* say_hello(void* arg)
{
    int i = *( (int *)arg );//对传入的参数进行强制转换
    cout&lt;&lt;&quot;Hello.....&quot;&lt;&lt;endl;
}

int ret = pthread_creat(&amp;tips,NULL,say_hello,(void *)&amp;i);</pre><ul><li>使用pthread_join等待线程结束</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>pthread_join(tips,NULL);</pre><p>  <br/></p><ul><li>线程创建时属性参数的设置pthread_attr_t及join功能的使用</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>typedef struct
{
     int detachstate;   //线程的分离状态
     int schedpolicy;   //线程调度策略
     struct sched_param schedparam;   //线程的调度参数
     int inheritsched; //线程的继承性 
     int scope; //线程的作用域 
     size_t guardsize; //线程栈末尾的警戒缓冲区大小 
     int stackaddr_set; 
     void * stackaddr; //线程栈的位置 
}pthread_attr_t;</pre><p>使用方法：</p><pre class='md-fences mock-cm' style='display:block;position:relative'>pthread_attr_t attr; //线程属性结构体，创建线程时加入的参数  
pthread_attr_init( &amp;attr ); //初始化  
pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_JOINABLE ); //是设置你想要指定线程属性参数，这个参数表明这个线程是可以join连接的join功能表示主程序可以等线程结束后再去做某事，实现了主程序和线程同步功能</pre><h2><a name='header-c232' class='md-header-anchor '></a>分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）</h2><ul><li>BOOL型变量</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>if(!var)</pre><p> </p><ul><li><p>int型变量</p><p> </p><p> if(var==0)</p></li></ul><ul><li>float型变量：</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>const float EPSINON = 0.00001;
if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;=EPSINON)</pre><p>  <br/></p><ul><li>指针变量</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>if(var==NULL)</pre><p>  <br/></p><h2><a name='header-c262' class='md-header-anchor '></a>内存的分配方式有几种</h2><ul><li>从静态存储区域分配:
 内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量</li><li>在栈上创建:
在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</li><li>从堆上分配，亦称动态内存分配:
程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</li></ul><h2><a name='header-c274' class='md-header-anchor '></a>内存操作</h2><ul><li>给绝对地址进行赋值操作</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>1.法一：
int *ptr;
ptr = (int *)0x10000;
*ptr = 1234;
2.晦涩的方法是:(建议使用第一中)
(unsigned int*)0x100000 = 1234;</pre><ul><li>程序跳转到绝对地址执行</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>1.//首先要将0x100000强制转换成函数指针,即:
(void (*)())0x100000
//然后再调用它:
*((void (*)())0x100000)();

2.用typedef可以看得更直观些:
typedef void(*)() voidFuncPtr;
*((voidFuncPtr)0x100000)();</pre><h2><a name='header-c288' class='md-header-anchor '></a>利用位运算实现加法</h2><pre class='md-fences mock-cm' style='display:block;position:relative'>int Add(int a, int b)
{
    if(b == 0)
        return a;
    int sum,carry;
    sum = a ^ b;
    carry = (a &amp; b) &lt;&lt; 1;
    return Add(sum, carry);
}</pre><h2><a name='header-c290' class='md-header-anchor '></a>判断计算机是大端存储还是小端存储</h2><pre class='md-fences mock-cm' style='display:block;position:relative'>void checkCPU()
{
    int i = 0x11223344;
    char *p;
    p = (char *)&i;
    if(*p == 0x44)
    {
        printf(&quot;小端存储\n&quot;);
    }else{
        printf(&quot;大端存储\n&quot;);
    }
}</pre><hr /><h1><a name='header-c293' class='md-header-anchor '></a>-&gt;数据结构&lt;-</h1><hr /><h2><a name='header-c295' class='md-header-anchor '></a>树的基本操作</h2><ul><li>定义</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>typedef struct BNode  
{  
  char value; 
  struct BNode *left;  
  struct BNode *right;  
} Node,*pNode,**ppNode; </pre><p> <br/></p><ul><li>获取二叉树叶子总数</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>int GetLeafeNum(pNode root)  
{  
    if(root==NULL)  //空节点叶子数为0  
    {  
        return 0;  
    }  
    else if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL)  
    {  
       return 1;  
    }  
    return GetLeafeNum(root-&gt;left)+GetLeafeNum(root-&gt;right);  
}  </pre><ul><li>获取二叉树的高度(左右子树最高高度+1)</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>int GetHeight(pNode root)  
{  
    if(root==NULL)  
    {  
        return 0;  
    }  
    // max(left,right)+1;  
    return (GetHeight(root-&gt;left)&gt;=GetHeight(root-&gt;right)?(GetHeight(root-&gt;left)+1):(GetHeight(root-&gt;right)+1));  
}  </pre><p> </p><ul><li>交换左右子树</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>void swap_tree(pNode root)  
{  
    if(root==NULL)  
        return;  
    else  
    {  
        pNode temp=root-&gt;left;  
        root-&gt;left=root-&gt;right;  
        root-&gt;right=temp;  
        swap_tree(root-&gt;left);  
        swap_tree(root-&gt;right);  
    }  
} </pre><h2><a name='header-c320' class='md-header-anchor '></a>链表的基本操作</h2><ul><li>定义</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>typedef struct student{
    int data;
    struct student *next;
}node;</pre><ul><li>单链表逆置</li></ul><pre class='md-fences mock-cm' style='display:block;position:relative'>node *reverse(node *head)
{
    node *p1,*p2,*p3;
    if(head == null || head-&gt;next == null)
        return head;
    p1 = head;
    p2 = p1-&gt;next;
    while(p2){
        p3 = p2-&gt;next;
        p2-&gt;next = p1;
        p1 = p2;
        p2 = p3;
    }
    head-&gt;next = NULL;
    head = p1;
    return head;
}</pre><p>  <br/>
  <br/>
  <br/>
  <br/>
  <br/></p></div>
</body>
</html>